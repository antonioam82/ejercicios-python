# Generar un laberinto grande con zonas abiertas ("plazas") en algunas posiciones
import random
from pathlib import Path

# Parámetros del laberinto con plazas
cols_plaza = 30
rows_plaza = 20
cell_size_plaza = 1.0
wall_thickness_plaza = 0.15
wall_height_plaza = 1.5
include_floor_plaza = False
plaza_probability = 0.07  # probabilidad de que una celda sea una "plaza"

# Inicializar estructura
maze_plaza = [[{"N": False, "S": False, "W": False, "E": False} for _ in range(cols_plaza)] for __ in range(rows_plaza)]
visited_plaza = [[False]*cols_plaza for _ in range(rows_plaza)]
directions = [("N", (0, -1)), ("S", (0, 1)), ("W", (-1, 0)), ("E", (1, 0))]

# Seleccionar plazas aleatorias (excepto borde)
plazas = set()
for r in range(1, rows_plaza-1):
    for c in range(1, cols_plaza-1):
        if random.random() < plaza_probability:
            plazas.add((r, c))

def inside_plaza(r, c):
    return 0 <= r < rows_plaza and 0 <= c < cols_plaza

def carve_from_plaza(r, c):
    visited_plaza[r][c] = True
    dirs = directions[:]
    random.shuffle(dirs)
    for name, (dc, dr) in [(d[0], (d[1][0], d[1][1])) for d in dirs]:
        nr = r + dr
        nc = c + dc
        if inside_plaza(nr, nc) and not visited_plaza[nr][nc]:
            if (r, c) in plazas or (nr, nc) in plazas:
                # abrir todo si una de las celdas es plaza
                maze_plaza[r][c]["N"] = True
                maze_plaza[r][c]["S"] = True
                maze_plaza[r][c]["W"] = True
                maze_plaza[r][c]["E"] = True
                maze_plaza[nr][nc]["N"] = True
                maze_plaza[nr][nc]["S"] = True
                maze_plaza[nr][nc]["W"] = True
                maze_plaza[nr][nc]["E"] = True
            else:
                if name == "N":
                    maze_plaza[r][c]["N"] = True
                    maze_plaza[nr][nc]["S"] = True
                elif name == "S":
                    maze_plaza[r][c]["S"] = True
                    maze_plaza[nr][nc]["N"] = True
                elif name == "W":
                    maze_plaza[r][c]["W"] = True
                    maze_plaza[nr][nc]["E"] = True
                elif name == "E":
                    maze_plaza[r][c]["E"] = True
                    maze_plaza[nr][nc]["W"] = True
            carve_from_plaza(nr, nc)

# Generar laberinto
carve_from_plaza(0, 0)

# Geometría
vertices_plaza = []
faces_plaza = []

def add_vertex_plaza(v):
    vertices_plaza.append(v)
    return len(vertices_plaza)

def add_box_plaza(x_min, y_min, x_max, y_max, z_min, z_max):
    v0 = add_vertex_plaza((x_min, y_min, z_min))
    v1 = add_vertex_plaza((x_max, y_min, z_min))
    v2 = add_vertex_plaza((x_max, y_max, z_min))
    v3 = add_vertex_plaza((x_min, y_max, z_min))
    v4 = add_vertex_plaza((x_min, y_min, z_max))
    v5 = add_vertex_plaza((x_max, y_min, z_max))
    v6 = add_vertex_plaza((x_max, y_max, z_max))
    v7 = add_vertex_plaza((x_min, y_max, z_max))
    faces_plaza.extend([
        (v1, v2, v3, v0),
        (v4, v5, v6, v7),
        (v0, v3, v7, v4),
        (v1, v5, v6, v2),
        (v3, v2, v6, v7),
        (v0, v4, v5, v1),
    ])

# Añadir paredes
for r in range(rows_plaza):
    for c in range(cols_plaza):
        if (r, c) in plazas:
            continue  # no poner paredes en la plaza
        x = c * cell_size_plaza
        y = r * cell_size_plaza
        cx = x
        cy = y
        if not maze_plaza[r][c]["N"]:
            add_box_plaza(cx - wall_thickness_plaza/2, cy - wall_thickness_plaza/2,
                          cx + cell_size_plaza + wall_thickness_plaza/2, cy + wall_thickness_plaza/2,
                          0.0, wall_height_plaza)
        if not maze_plaza[r][c]["S"]:
            add_box_plaza(cx - wall_thickness_plaza/2, cy + cell_size_plaza - wall_thickness_plaza/2,
                          cx + cell_size_plaza + wall_thickness_plaza/2, cy + cell_size_plaza + wall_thickness_plaza/2,
                          0.0, wall_height_plaza)
        if not maze_plaza[r][c]["W"]:
            add_box_plaza(cx - wall_thickness_plaza/2, cy - wall_thickness_plaza/2,
                          cx + wall_thickness_plaza/2, cy + cell_size_plaza + wall_thickness_plaza/2,
                          0.0, wall_height_plaza)
        if not maze_plaza[r][c]["E"]:
            add_box_plaza(cx + cell_size_plaza - wall_thickness_plaza/2, cy - wall_thickness_plaza/2,
                          cx + cell_size_plaza + wall_thickness_plaza/2, cy + cell_size_plaza + wall_thickness_plaza/2,
                          0.0, wall_height_plaza)

# Guardar OBJ
obj_lines_plaza = ["# Large maze with plazas generated by ChatGPT\n"]
for vx, vy, vz in vertices_plaza:
    obj_lines_plaza.append(f"v {vx:.6f} {vy:.6f} {vz:.6f}\n")
for face in faces_plaza:
    obj_lines_plaza.append("f " + " ".join(str(i) for i in face) + "\n")

out_path_plaza = Path("maze_large_with_plazes.obj")
out_path_plaza.write_text("".join(obj_lines_plaza), encoding="utf-8")

print(f"Laberinto con plazas generado con {len(vertices_plaza)} vértices y {len(faces_plaza)} caras.")
print(f"Guardado en: {out_path_plaza}")
